:py:mod:`test_play`
===================

.. py:module:: test_play


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   test_play.SkillBase
   test_play.SkillA
   test_play.SkillB
   test_play.SkillC
   test_play.Skills
   test_play.TacticBase



Functions
~~~~~~~~~

.. autoapisummary::

   test_play.get_tactic_ctx
   test_play.test_flatten_requests



.. py:class:: SkillBase

   Bases: :py:obj:`stp.skill.ISkill`

   .. py:method:: define(self)


   .. py:method:: __repr__(self) -> str


   .. py:method:: tick(self) -> None



.. py:class:: SkillA

   Bases: :py:obj:`SkillBase`


.. py:class:: SkillB

   Bases: :py:obj:`SkillBase`


.. py:class:: SkillC

   Bases: :py:obj:`SkillBase`


.. py:class:: Skills

   Bases: :py:obj:`stp.tactic.SkillsEnum`

   .. py:attribute:: A1
      

      

   .. py:attribute:: A2
      

      

   .. py:attribute:: B1
      

      

   .. py:attribute:: B2
      

      

   .. py:attribute:: C1
      

      

   .. py:attribute:: C2
      

      


.. py:class:: TacticBase(ctx: stp.tactic.Ctx)

   Bases: :py:obj:`stp.tactic.ITactic`\ [\ :py:obj:`None`\ ]

   .. py:method:: compute_props(self, prev_props: None) -> None


   .. py:method:: create_request(self) -> stp.role.RoleRequest


   .. py:method:: tick(self, role_results: stp.tactic.RoleResults, props: None) -> List[stp.action.IAction]


   .. py:method:: get_requests(self, world_state: stp.rc.WorldState, props: None) -> stp.tactic.RoleRequests



.. py:function:: get_tactic_ctx() -> stp.tactic.Ctx

   Creates a simple tactic context for convenience.
   :return: Tactic context containing SkillA, SkillB and SkillC.


.. py:function:: test_flatten_requests() -> None

   Tests that play.flatten_requests works as expected.


