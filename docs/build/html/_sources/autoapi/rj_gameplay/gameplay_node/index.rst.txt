:py:mod:`rj_gameplay.gameplay_node`
===================================

.. py:module:: rj_gameplay.gameplay_node

.. autoapi-nested-parse::

   ROS entry point into Python-side gameplay library.
   Alternatively, where gameplay cedes control to cpp motion control/planning.

   Contains TestPlaySelector, GameplayNode, and main() which spins GameplayNode
   and allows the PlaySelector to be changed between Test and other forms.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   rj_gameplay.gameplay_node.GameplayNode



Functions
~~~~~~~~~

.. autoapisummary::

   rj_gameplay.gameplay_node.main



Attributes
~~~~~~~~~~

.. autoapisummary::

   rj_gameplay.gameplay_node.NUM_ROBOTS


.. py:data:: NUM_ROBOTS
   :annotation: = 16

   

.. py:class:: GameplayNode(play_selector: stp.situation.IPlaySelector, test_play: Optional[stp.play.Play] = None, world_state: Optional[stp.rc.WorldState] = None)

   Bases: :py:obj:`rclpy.node.Node`

   A node which subscribes to the world_state, game state, robot status, and
   field topics and converts the messages to python types.

   .. py:method:: set_play_state(self, play_state: rj_msgs.msg.PlayState)


   .. py:method:: set_match_state(self, match_state: rj_msgs.msg.MatchState)


   .. py:method:: debug_callback(self)

      Publishes the string that shows up in the behavior tree in the Soccer UI.


   .. py:method:: create_partial_world_state(self, msg: GameplayNode.create_partial_world_state.msg) -> None

      Creates a partial world state from a world state message


   .. py:method:: create_partial_robots(self, msg: GameplayNode.create_partial_robots.msg) -> None

      Creates the robot status which makes up part of the whole Robot class


   .. py:method:: build_game_info(self) -> Optional[stp.rc.GameInfo]

      Create game info object from Game State message


   .. py:method:: create_field(self, msg: GameplayNode.create_field.msg) -> None

      Creates field object from Field Dimensions message


   .. py:method:: create_goalie_id(self, msg: GameplayNode.create_goalie_id.msg) -> None

      Set game_info's goalie_id based on goalie msg


   .. py:method:: update_world_state(self) -> None

      returns: an updated world state


   .. py:method:: gameplay_tick(self) -> None

      Get situation, play from self.play_selector and update the currently running play if needed.
      Then, add field and game_info to world_state, and push global obstacles to motion planning.


   .. py:method:: add_def_areas_to_obs(self, def_area_obstacles, game_info) -> None

      Creates and publishes rectangles for the defense area in front of both goals.

      The defense area, per the rules, is the box in front of each goal where
      only that team's goalie can be in and touch the ball.

      (Formerly referred to as "goal_zone_obstacles".)


   .. py:method:: add_goals_to_global_obs(self, global_obstacles, game_info)

      Adds the physical walls that form each goal to global_obstacles.


   .. py:method:: add_ball_to_global_obs(self, global_obstacles, game_info)

      Adds circular no-fly zone around ball during stops or restarts,
      to comply with rulebook.


   .. py:method:: tick_override_actions(self, world_state) -> None


   .. py:method:: clear_override_actions(self) -> None


   .. py:method:: shutdown(self) -> None

      destroys node



.. py:function:: main()


