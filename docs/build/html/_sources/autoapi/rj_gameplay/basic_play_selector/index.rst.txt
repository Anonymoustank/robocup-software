:py:mod:`rj_gameplay.basic_play_selector`
=========================================

.. py:module:: rj_gameplay.basic_play_selector


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   rj_gameplay.basic_play_selector.BallPos
   rj_gameplay.basic_play_selector.FieldLoc
   rj_gameplay.basic_play_selector.HeuristicInformation
   rj_gameplay.basic_play_selector.BasicPlaySelector




Attributes
~~~~~~~~~~

.. autoapisummary::

   rj_gameplay.basic_play_selector.POSSESS_MIN_DIST
   rj_gameplay.basic_play_selector.MIN_PASS_SPEED
   rj_gameplay.basic_play_selector.MIN_NEAR_BALL_DIST


.. py:data:: POSSESS_MIN_DIST
   :annotation: = 0.15

   

.. py:data:: MIN_PASS_SPEED
   :annotation: = 0.9

   

.. py:data:: MIN_NEAR_BALL_DIST
   :annotation: = 0.35

   

.. py:class:: BallPos

   Bases: :py:obj:`enum.Enum`

   Enum for representing the possession of the ball.

   .. py:attribute:: OUR_BALL
      :annotation: = 1

      

   .. py:attribute:: FREE_BALL
      :annotation: = 2

      

   .. py:attribute:: THEIR_BALL
      :annotation: = 3

      

   .. py:attribute:: CONTEST_BALL
      :annotation: = 4

      


.. py:class:: FieldLoc

   Bases: :py:obj:`enum.Enum`

   Enum for representing where the ball is on the field.

   .. py:attribute:: DEFEND_SIDE
      :annotation: = 1

      

   .. py:attribute:: MIDFIELD
      :annotation: = 2

      

   .. py:attribute:: ATTACK_SIDE
      :annotation: = 3

      


.. py:class:: HeuristicInformation(world_state: stp.rc.WorldState, game_info: stp.rc.GameInfo)

   Class that represents all the heuristic information needed by the decision
   tree situation analyzer.

   .. py:attribute:: __slots__
      :annotation: = ['ball_pos', 'field_loc', 'is_pileup']

      

   .. py:attribute:: ball_pos
      :annotation: :BallPos

      

   .. py:attribute:: field_loc
      :annotation: :FieldLoc

      

   .. py:attribute:: is_pileup
      :annotation: :bool

      

   .. py:method:: __calc_field_loc(world_state: stp.rc.WorldState, game_info: stp.rc.GameInfo) -> FieldLoc
      :staticmethod:

      Computes the current location of the ball.
      :param world_state:
      :param game_info:
      :return: The current FieldLoc.


   .. py:method:: __calc_ball_poss(world_state: stp.rc.WorldState, game_info: stp.rc.GameInfo) -> BallPos
      :staticmethod:

      Computes the current ball possession.
      :param world_state:
      :param game_info:
      :return: The current BallPos.


   .. py:method:: __calc_pileup(world_state: stp.rc.WorldState, game_info: stp.rc.GameInfo) -> bool
      :staticmethod:

      Computes whether there is a pileup or not.
      :param world_state:
      :param game_info:
      :return: The current BallPos.



.. py:class:: BasicPlaySelector

   Bases: :py:obj:`stp.situation.IPlaySelector`

   Play selector that returns a play and situation based on world state
   (see select method)

   .. py:method:: select(self, world_state: stp.rc.WorldState) -> Tuple[Optional[stp.situation.ISituation], stp.play.IPlay]

      Returns the best situation and play
      for the current world state based on a hardcoded
      decision tree.
      :param world_state: The current state of the world.
      :param game_info: The information about the state of the game.
      :return: The best situation for the current world state.


   .. py:method:: __analyze_restart(world_state: stp.rc.WorldState, heuristics: HeuristicInformation) -> stp.situation.ISituation
      :staticmethod:


   .. py:method:: __repr__(self)

      returns the string with the current situation.



