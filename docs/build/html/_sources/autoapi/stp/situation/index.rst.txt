:py:mod:`stp.situation`
=======================

.. py:module:: stp.situation

.. autoapi-nested-parse::

   This module contains the interfaces ISituation, IAnalyzer and IPlaySelector.



Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   stp.situation.Play
   stp.situation.ISituation
   stp.situation.IAnalyzer
   stp.situation.IPlaySelector




.. py:class:: Play

   Bases: :py:obj:`abc.ABC`

   Coordinate full-team behaviors via Tactics. Assumes number of Roles matches number of robots on the field.
   Ends when SituationAnalysis switches the Play, so no is_done() necessary.
   See tick() for more details on behavior.

   .. py:method:: tick(self, world_state: stp.rc.WorldState) -> List[rj_msgs.msg.RobotIntent]
      :abstractmethod:

      Performs one "tick" of the specified play.

      This should:
          1. Determine if role assignment is necessary.
          2. If so, perform role assignment with self.assign_roles().
          3. Tick Tactics to aggregate robot_intents with self.get_robot_intents().

      :param world_state: Current state of the world.
      :return: list of robot intents where index = robot_id


   .. py:method:: assign_roles(self, world_state: stp.rc.WorldState) -> None

      Given that all Roles are in sorted order of priority, greedily assign the highest-priority Role to the lowest-cost robot for that Role.
      Instantiate Tactics with the correct robots post-assignment. (Note that this behavior is largely handled by the init_roles() of each Tactic.)
      Satisfy constraint that all Roles of a Tactic must all be assigned at once.
      If a Tactic's Roles cannot all be filled, none will be filled and a debug message signifying error is displayed along with the tactic's tick not running."


   .. py:method:: get_robot_intents(self, world_state: stp.rc.WorldState) -> List[rj_msgs.msg.RobotIntent]

      Has to be called after assigned_roles has been called.
      Tick each tactic to get a list of RobotIntents for GameplayNode. Each RobotIntent in this list is at index robot_id, or in Python terms: return_list[robot_id] = robot_intent


   .. py:method:: __repr__(self)

      returns the string with the current play and the current state of the play.



.. py:class:: ISituation

   Bases: :py:obj:`abc.ABC`

   Interface for a situation.


.. py:class:: IAnalyzer

   Bases: :py:obj:`abc.ABC`

   Interface for situation analyzer.

   .. py:method:: analyze_situation(self, world_state: stp.rc.WorldState, game_info: stp.rc.GameInfo) -> ISituation
      :abstractmethod:

      Returns the best situation for the current world state.
      :param world_state: The current state of the world.
      :param game_info: The information about the state of the game.
      :return: The best situation for the current world state.



.. py:class:: IPlaySelector

   Bases: :py:obj:`abc.ABC`

   Abstract class for play selector.

   .. py:method:: select(self, world_state: stp.rc.WorldState) -> Tuple[Optional[ISituation], stp.play.Play]
      :abstractmethod:

      Selects the best situation and play given given the current world state.
      :param world_state: The current state of the world.
      :return: A tuple of the best situation and best play.



