:py:mod:`stp.play`
==================

.. py:module:: stp.play

.. autoapi-nested-parse::

   This module contains data structures for the Plays level of STP.



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   pure_play/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   stp.play.IPlay
   stp.play.Play




Attributes
~~~~~~~~~~

.. autoapisummary::

   stp.play.PropT


.. py:data:: PropT
   

   

.. py:class:: IPlay

   Bases: :py:obj:`abc.ABC`

   Helper class that provides a standard way to create an ABC using
   inheritance.


.. py:exception:: RoleAssignFailure

   Bases: :py:obj:`Exception`

   Common base class for all non-exit exceptions.


.. py:class:: Play

   Bases: :py:obj:`abc.ABC`

   Coordinate full-team behaviors via Tactics. Assumes number of Roles matches number of robots on the field.
   Ends when SituationAnalysis switches the Play, so no is_done() necessary.
   See tick() for more details on behavior.

   .. py:method:: tick(self, world_state: stp.rc.WorldState) -> List[rj_msgs.msg.RobotIntent]
      :abstractmethod:

      Performs one "tick" of the specified play.

      This should:
          1. Determine if role assignment is necessary.
          2. If so, perform role assignment with self.assign_roles().
          3. Tick Tactics to aggregate robot_intents with self.get_robot_intents().

      :param world_state: Current state of the world.
      :return: list of robot intents where index = robot_id


   .. py:method:: assign_roles(self, world_state: stp.rc.WorldState) -> None

      Given that all Roles are in sorted order of priority, greedily assign the highest-priority Role to the lowest-cost robot for that Role.
      Instantiate Tactics with the correct robots post-assignment. (Note that this behavior is largely handled by the init_roles() of each Tactic.)
      Satisfy constraint that all Roles of a Tactic must all be assigned at once.
      If a Tactic's Roles cannot all be filled, none will be filled and a debug message signifying error is displayed along with the tactic's tick not running."


   .. py:method:: get_robot_intents(self, world_state: stp.rc.WorldState) -> List[rj_msgs.msg.RobotIntent]

      Has to be called after assigned_roles has been called.
      Tick each tactic to get a list of RobotIntents for GameplayNode. Each RobotIntent in this list is at index robot_id, or in Python terms: return_list[robot_id] = robot_intent


   .. py:method:: __repr__(self)

      returns the string with the current play and the current state of the play.



